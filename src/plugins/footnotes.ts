/**
 * NOTE:
 *
 * In this module, "endnote" refers to notes collected at the end of the
 * document as generated by mdast-util-to-hast, while "footnote" refers to
 * notes that float to the bottom of each page as defined by
 * [css-gcpm](https://www.w3.org/TR/css-gcpm-3/#footnotes).
 * This does not match the export names or attribute naming used by remark.
 *
 * Terminology follows css-gcpm: a "call" is the in-text marker showing the
 * note number, an "element" is the note content itself, and an "area" is the
 * region where notes are collected for display.
 *
 * In remark 13+ / mdast-util-to-hast 13+, footnotes are handled via remark-gfm.
 * The endnote HTML format has changed:
 *   - area: <section data-footnotes class="footnotes">
 *   - elements: <li id="user-content-fn-IDENTIFIER">
 *   - calls: <sup><a href="#user-content-fn-..." id="user-content-fnref-..." ...>
 *   - back references: <a href="#user-content-fnref-..." class="data-footnote-backref" ...>
 */

import type * as hast from 'hast';
import { selectAll } from 'hast-util-select';
import { h } from 'hastscript';
import type { Handler as ToHastHandler, State } from 'mdast-util-to-hast';
import type { Plugin, PluggableList } from 'unified';
import { u } from 'unist-builder';
import { visit as visitTree } from 'unist-util-visit';

type ElementWithProps = hast.Element & {
  properties: NonNullable<hast.Element['properties']>;
};

/**
 * Selectors for remark-gfm / mdast-util-to-hast v13 footnote output.
 * @see https://github.com/syntax-tree/mdast-util-to-hast/blob/main/lib/footer.js
 */
const endnoteAreaSelector = 'section[data-footnotes].footnotes';
type EndnoteArea = hast.Element & {
  tagName: 'section';
  properties: { className: ['footnotes']; dataFootnotes: true };
};
const selectEndnoteAreas = (tree: hast.Root) =>
  selectAll(endnoteAreaSelector, tree) as EndnoteArea[];

const endnoteElementSelector = `${endnoteAreaSelector} ol li[id^="fn-"]`;
type EndnoteElement = hast.Element & {
  tagName: 'li';
  properties: { id: `fn-${string}` };
};
const selectEndnoteElements = (tree: hast.Root) =>
  selectAll(endnoteElementSelector, tree) as EndnoteElement[];

const endnoteCallSelector =
  'sup:has(a[href^="#fn-"][data-footnote-ref])';
type EndnoteCall = hast.Element & {
  tagName: 'sup';
};
const selectEndnoteCalls = (tree: hast.Root) =>
  selectAll(endnoteCallSelector, tree) as EndnoteCall[];

const endnoteBackReferenceSelector = 'a.data-footnote-backref';
type EndnoteBackReference = hast.Element & {
  tagName: 'a';
  properties: { className: ['data-footnote-backref'] };
};
const selectEndnoteBackReferences = (parent: hast.Element) =>
  selectAll(endnoteBackReferenceSelector, parent) as EndnoteBackReference[];

/**
 * Transform the endnote link with Pandoc format.
 */
const endnoteCallsToPandoc: Plugin = () => (tree) => {
  selectEndnoteCalls(tree as hast.Root).forEach((call, i) => {
    const sup: ElementWithProps = call as ElementWithProps;
    // Find the anchor child
    const anchor = sup.children.find(
      (c): c is hast.Element & { tagName: 'a' } =>
        c.type === 'element' && c.tagName === 'a',
    );
    if (!anchor) return;

    const refIndex = i + 1;

    // Mutate sup into <a class="footnote-ref">
    sup.tagName = 'a';
    sup.properties = {
      id: `fnref${refIndex}`,
      href: `#fn${refIndex}`,
      className: ['footnote-ref'],
      role: 'doc-noteref',
    };

    // Mutate anchor into <sup>N</sup>
    (anchor as ElementWithProps).tagName = 'sup';
    (anchor as ElementWithProps).properties = {};
    (anchor as ElementWithProps).children = [u('text', `${refIndex}`)];
  });
};

/**
 * Transform the endnote with Pandoc format.
 */
const endnoteAreasToPandoc: Plugin = () => (tree) => {
  const root = tree as hast.Root;

  // must be called before mutating area properties
  const endnoteElements = selectEndnoteElements(root);

  selectEndnoteAreas(root).forEach((area: ElementWithProps) => {
    area.properties.role = 'doc-endnotes';
    area.properties.className = ['footnotes'];
    // Remove data-footnotes attribute
    delete (area.properties as Record<string, unknown>).dataFootnotes;

    // Replace <h2 class="sr-only" id="footnote-label">Footnotes</h2> with <hr>
    const newChildren: hast.ElementContent[] = [];
    for (const child of area.children) {
      if (
        child.type === 'element' &&
        child.tagName === 'h2' &&
        (child.properties as any)?.id === 'footnote-label'
      ) {
        newChildren.push({
          type: 'element',
          tagName: 'hr',
          properties: {},
          children: [],
        });
      } else {
        newChildren.push(child);
      }
    }
    area.children = newChildren;
  });

  endnoteElements.forEach((elem: ElementWithProps, i) => {
    const refIndex = i + 1;

    elem.properties.id = `fn${refIndex}`;
    elem.properties.role = 'doc-endnote';

    selectEndnoteBackReferences(elem).forEach((backref: ElementWithProps) => {
      backref.properties = {
        href: `#fnref${refIndex}`,
        className: ['footnote-back'],
        role: 'doc-backlink',
      };
      // Set content to ↩
      backref.children = [u('text', '↩')];
    });

    // Unwrap single-paragraph content to match old format (tight list-item behavior)
    // <li>\n<p>content <a>↩</a></p>\n</li> → <li>content<a>↩</a></li>
    const nonWhitespace = elem.children.filter(
      (c) => !(c.type === 'text' && /^\s*$/.test((c as hast.Text).value)),
    );
    if (
      nonWhitespace.length === 1 &&
      nonWhitespace[0].type === 'element' &&
      (nonWhitespace[0] as hast.Element).tagName === 'p'
    ) {
      const p = nonWhitespace[0] as hast.Element;
      // Remove or trim whitespace before backref links
      elem.children = p.children.reduce<hast.ElementContent[]>((acc, c, idx) => {
        const next = p.children[idx + 1];
        const nextIsBackref =
          next &&
          next.type === 'element' &&
          (next as hast.Element).tagName === 'a' &&
          ((next as hast.Element).properties as any)?.role === 'doc-backlink';

        if (c.type === 'text' && nextIsBackref) {
          const trimmed = (c as hast.Text).value.replace(/\s+$/, '');
          if (trimmed) {
            acc.push({ ...c, value: trimmed } as hast.Text);
          }
          // Skip whitespace-only text nodes
        } else {
          acc.push(c);
        }
        return acc;
      }, []);
    }
  });
};

/**
 * The returned Element is expected to be phrasing content per the HTML
 * content model. If a flow content element (e.g. `<aside>`) is returned,
 * it will be rewritten to `<span>` with a warning.
 */
export type FootnoteFactory = (
  h: typeof import('hastscript').h,
  properties: hast.Properties,
  children: hast.ElementContent[],
) => hast.Element;

export type FootnoteOptions = {
  endnotesAsFootnotes?: boolean | hast.Properties | FootnoteFactory;
};

/**
 * Data attribute used to embed a warning message in the hast element itself.
 * {@link reportFootnoteWarnings} picks it up, reports via `file.message()`,
 * and removes it.
 */
const warningAttr = 'data-vfm-warning';
const warningProp = 'dataVfmWarning';
const warningSelector = `[${warningAttr}]`;

/**
 * Pick up warnings embedded as {@link warningAttr} in hast elements,
 * report them via `file.message()`, and remove the attribute.
 */
const reportFootnoteWarnings: Plugin = () => (tree, file) => {
  selectAll(warningSelector, tree as hast.Root).forEach((el) => {
    const props = el.properties as Record<string, unknown> | undefined;
    const msg = props?.[warningProp];
    if (typeof msg === 'string') {
      file.message(msg);
      delete props![warningProp];
    }
  });
};

/**
 * Elements whose start tag triggers implicit `<p>` end tag per the HTML
 * parsing algorithm. A FootnoteFactory returning one of these will be
 * rewritten to `<span>` with a warning.
 * @see https://html.spec.whatwg.org/multipage/grouping-content.html#the-p-element
 */
const pClosingTagNames = new Set([
  'address',
  'article',
  'aside',
  'blockquote',
  'details',
  'dialog',
  'div',
  'dl',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'header',
  'hgroup',
  'hr',
  'main',
  'menu',
  'nav',
  'ol',
  'p',
  'pre',
  'search',
  'section',
  'table',
  'ul',
]);

type BuildFootnote = (
  id: string,
  children: hast.ElementContent[],
) => hast.Element;

const createBuildFootnote =
  (factory: FootnoteFactory): BuildFootnote =>
  (id, children) => {
    const result = factory(h, { id }, children);
    if (pClosingTagNames.has(result.tagName)) {
      const msg =
        `FootnoteFactory returned <${result.tagName}>, which triggers` +
        ` <p> auto-closing. Rewriting to <span>.`;
      result.tagName = 'span';
      (result.properties as Record<string, unknown>)[warningProp] = msg;
    }
    return result;
  };

const createInlineFootnoteHandler =
  (buildFootnote: BuildFootnote): ToHastHandler =>
  (ctx: State, node: any) => {
    let no = 1;
    while (ctx.footnoteById.has(String(no))) {
      no++;
    }
    const identifier = String(no);
    ctx.footnoteById.set(identifier, {
      type: 'footnoteDefinition',
      identifier,
      children: [{ type: 'paragraph', children: node.children }],
      position: node.position,
    });
    return buildFootnote(`fn-${identifier}`, ctx.all(node));
  };

const createFootnoteReferenceHandler =
  (buildFootnote: BuildFootnote): ToHastHandler =>
  (ctx: State, node: any) => {
    const identifier = String(node.identifier);
    const def = ctx.footnoteById.get(identifier.toUpperCase());
    if (!def) return undefined;
    return buildFootnote(
      `fn-${identifier}`,
      ctx.all(
        // Unwrap single-paragraph definitions to produce inline content
        def.children.length === 1 && def.children[0].type === 'paragraph'
          ? def.children[0]
          : def,
      ),
    );
  };

/**
 * Create mdast-to-hast handlers and hast transformers for footnote processing.
 *
 * When `endnotesAsFootnotes` is disabled (default):
 * - `toHastHandlers` is empty; the default mdast-util-to-hast handlers
 *   generate endnote sections.
 * - `hastTransformers` rewrites the endnote markup to Pandoc format.
 *
 * When `endnotesAsFootnotes` is enabled:
 * - `toHastHandlers` provides custom `footnoteReference` and `footnote`
 *   handlers that produce footnote elements at the call site, bypassing
 *   endnote section generation.
 * - If a {@link FootnoteFactory} returns a flow content element that would
 *   trigger `<p>` auto-closing in rehype-raw, the element is rewritten to
 *   `<span>` and a warning is reported via `VFile#messages`.
 *
 * @param options Footnote options.
 * @returns `toHastHandlers` for remark-rehype and `hastTransformers` as
 *   unified plugins to be spread into the pipeline.
 */
export const createFootnotePlugin = (
  options?: FootnoteOptions,
): {
  toHastHandlers: Record<string, ToHastHandler> | {};
  hastTransformers: PluggableList;
} => {
  const opt = options?.endnotesAsFootnotes;

  if (!opt) {
    return {
      toHastHandlers: {},
      hastTransformers: [endnoteCallsToPandoc, endnoteAreasToPandoc],
    };
  }

  const buildFootnote = createBuildFootnote(
    typeof opt === 'function'
      ? opt
      : typeof opt === 'object'
      ? (hFn, props, children) => hFn('span', { ...props, ...opt }, ...children)
      : (hFn, props, children) =>
          hFn('span', { class: 'footnote', ...props }, ...children),
  );

  return {
    toHastHandlers: {
      footnoteReference: createFootnoteReferenceHandler(buildFootnote),
      footnote: createInlineFootnoteHandler(buildFootnote),
    },
    hastTransformers: [reportFootnoteWarnings],
  };
};

/**
 * Process Markdown AST.
 * Transforms inline footnotes `^[content]` into footnoteDefinition + footnoteReference
 * nodes, since remark-gfm does not support inline footnote syntax.
 */
export const mdast: Plugin = () => (tree: any) => {
  let counter = 0;
  const definitions: any[] = [];

  visitTree(tree, 'text', (node: any, index: number | undefined, parent: any) => {
    if (!parent || typeof index !== 'number') return;
    const value: string = node.value;
    const parts: any[] = [];
    let lastIndex = 0;
    // Match ^[...] but handle nested brackets
    const regex = /\^\[/g;
    let match;
    while ((match = regex.exec(value)) !== null) {
      const start = match.index;
      // Find matching closing bracket
      let depth = 1;
      let i = start + 2;
      while (i < value.length && depth > 0) {
        if (value[i] === '[') depth++;
        else if (value[i] === ']') depth--;
        i++;
      }
      if (depth !== 0) continue;
      const end = i;
      const content = value.slice(start + 2, end - 1);

      // Add text before the footnote
      if (start > lastIndex) {
        parts.push({ type: 'text', value: value.slice(lastIndex, start) });
      }

      // Create unique identifier for this inline footnote
      // Use a high-range counter to avoid collision with user-defined footnotes
      counter++;
      const id = `_inline_${counter}`;

      // Create footnoteReference
      parts.push({
        type: 'footnoteReference',
        identifier: id,
        label: id,
      });

      // Create footnoteDefinition to be added to root
      definitions.push({
        type: 'footnoteDefinition',
        identifier: id,
        label: id,
        children: [{ type: 'paragraph', children: [{ type: 'text', value: content }] }],
      });

      lastIndex = end;
      regex.lastIndex = end;
    }

    if (parts.length > 0) {
      if (lastIndex < value.length) {
        parts.push({ type: 'text', value: value.slice(lastIndex) });
      }
      parent.children.splice(index, 1, ...parts);
    }
  });

  // Add all inline footnote definitions to the root
  if (definitions.length > 0) {
    tree.children.push(...definitions);
  }
};

