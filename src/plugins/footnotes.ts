/**
 * NOTE:
 *
 * In this module, "endnote" refers to notes collected at the end of the
 * document as generated by mdast-util-to-hast, while "footnote" refers to
 * notes that float to the bottom of each page as defined by
 * [css-gcpm](https://www.w3.org/TR/css-gcpm-3/#footnotes).
 * This does not match the export names or attribute naming used by remark.
 *
 * Terminology follows css-gcpm: a "call" is the in-text marker showing the
 * note number, an "element" is the note content itself, and an "area" is the
 * region where notes are collected for display.
 *
 * VFM depends on two versions of mdast-util-to-hast;
 * endnote generation uses the one resolved via remark-rehype:
 *  `- remark-rehype@8.1.0
 *  |   `- mdast-util-to-hast@10.2.0  <-- this one
 *  `- mdast-util-to-hast@11.3.0
 */

import { Element, ElementContent, Properties, Root as HastRoot } from 'hast';
import { selectAll } from 'hast-util-select';
import { h } from 'hastscript';
import /* footnotes as */ endnotes from 'remark-footnotes';
import { u } from 'unist-builder';
import { EXIT, SKIP, visitParents } from 'unist-util-visit-parents';

type ElementWithProps = Element & {
  properties: NonNullable<Element['properties']>;
};

/**
 * @see https://github.com/syntax-tree/mdast-util-to-hast/blob/10.2.0/lib/footer.js#L55-L66
 */
const endnoteAreaSelector = 'div.footnotes';
type EndnoteArea = Element & {
  tagName: 'div';
  properties: { className: ['footnotes'] };
};
const selectEndnoteAreas = (tree: HastRoot) =>
  selectAll(endnoteAreaSelector, tree) as EndnoteArea[];
const endnoteElementSelector = `${endnoteAreaSelector} ol li[id^="fn-"]`;

/**
 * @see https://github.com/syntax-tree/mdast-util-to-hast/blob/10.2.0/lib/footer.js#L43-L48
 */
type EndnoteElement = Element & {
  tagName: 'li';
  properties: { id: `fn-${string}` };
};
const selectEndnoteElements = (tree: HastRoot) =>
  selectAll(endnoteElementSelector, tree) as EndnoteElement[];

/**
 * @see https://github.com/syntax-tree/mdast-util-to-hast/blob/10.2.0/lib/handlers/footnote-reference.js#L15-L19
 */
const endnoteCallSelector =
  'sup[id^="fnref-"]:has(a:only-child[href^="#fn-"].footnote-ref)';
type EndnoteCall = Element & {
  tagName: 'sup';
  properties: { id: `fnref-${string}` };
  children: [
    Element & {
      tagName: 'a';
      properties: {
        href: `#${string}`;
        className: ['footnote-ref'];
      };
    },
  ];
};
const selectEndnoteCalls = (tree: HastRoot) =>
  selectAll(endnoteCallSelector, tree) as EndnoteCall[];

/**
 * @see https://github.com/syntax-tree/mdast-util-to-hast/blob/10.2.0/lib/footer.js#L29-L34
 */
const backReferenceSelector = 'a.footnote-backref';
type BackReference = Element & {
  tagName: 'a';
  properties: { className: ['footnote-backref'] };
};
const isBackReference = (node: ElementContent): node is BackReference =>
  node.type === 'element' &&
  node.tagName === 'a' &&
  Array.isArray((node as Element).properties?.className) &&
  ((node as Element).properties!.className as string[]).includes(
    'footnote-backref',
  );
const selectBackReferences = (parent: Element) =>
  selectAll(backReferenceSelector, parent) as BackReference[];

const removeElement = (tree: HastRoot, target: Element) => {
  visitParents(tree, 'element', (node, ancestors) => {
    const parent = ancestors.at(-1);
    if (!parent) {
      return; // Root
    }
    if (node !== target) {
      return;
    }
    parent.children = parent.children.filter((c) => c !== node);
    return EXIT;
  });
};

/**
 * Transform the endnote link with Pandoc format.
 * @param tree Tree of Hypertext AST.
 */
const transformEndnoteCalls = (tree: HastRoot) => {
  selectEndnoteCalls(tree).forEach((call, i) => {
    const sup: ElementWithProps = call;
    const [anchor]: [ElementWithProps] = call.children;

    const refIndex = i + 1;

    // Mutate sup into <a class="footnote-ref">
    sup.tagName = 'a';
    sup.properties = {
      id: `fnref${refIndex}`,
      href: `#fn${refIndex}`,
      className: ['footnote-ref'],
      role: 'doc-noteref',
    };

    // Mutate anchor into <sup>N</sup>
    anchor.tagName = 'sup';
    anchor.properties = {};
    anchor.children = [u('text', `${refIndex}`)];
  });
};

/**
 * Transform the endnote with Pandoc format.
 * @param tree Tree of Hypertext AST.
 */
const transformEndnoteAreas = (tree: HastRoot) => {
  // must be called before mutating area.tagName
  const endnoteElements = selectEndnoteElements(tree);

  selectEndnoteAreas(tree).forEach((area: ElementWithProps) => {
    area.tagName = 'section';
    area.properties.role = 'doc-endnotes';
  });

  endnoteElements.forEach((elem: ElementWithProps, i) => {
    const refIndex = i + 1;

    elem.properties.id = `fn${refIndex}`;
    elem.properties.role = 'doc-endnote';

    // Back reference is expected to be placed at the end of contents
    // @see https://github.com/syntax-tree/mdast-util-to-hast/blob/10.2.0/lib/footer.js#L41
    selectBackReferences(elem).forEach((backref: ElementWithProps) => {
      backref.properties.href = `#fnref${refIndex}`;
      backref.properties.className = ['footnote-back'];
      backref.properties.role = 'doc-backlink';
    });
  });
};

export type FootnoteFactory = (
  h: typeof import('hastscript').h,
  children: ElementContent[],
) => Element;

export type FootnoteOptions = {
  endnotesAsFootnotes?: boolean | Properties | FootnoteFactory;
};

/**
 * Convert endnotes to inline footnotes for CSS GCPM `float: footnote`.
 *
 * @param tree HAST tree.
 * @param options Footnote options.
 */
const convertEndnotesToFootnotes = (
  tree: HastRoot,
  options: FootnoteOptions,
) => {
  const opt = options.endnotesAsFootnotes;
  const factory: FootnoteFactory =
    typeof opt === 'function'
      ? opt
      : typeof opt === 'object'
      ? (h, children) => h('span', opt, ...children)
      : (h, children) => h('span', { class: 'footnote' }, ...children);

  const endnoteElements = new Map(
    selectEndnoteElements(tree).map((elem) => [
      elem.properties.id as string,
      elem.children.filter((child) => !isBackReference(child)),
    ]),
  );

  const endnoteCallReplacements = new Map(
    selectEndnoteCalls(tree).flatMap((call) => {
      const id = call.children[0].properties.href.slice(1);
      const elem = endnoteElements.get(id);
      return !elem ? [] : [[call as Element, factory(h, elem)]];
    }),
  );

  visitParents(tree, 'element', (el, ancestors) => {
    const parent = ancestors.at(-1);
    if (!parent) {
      return; // Root
    }
    const replacement = endnoteCallReplacements.get(el);
    if (!replacement) {
      return;
    }
    parent.children = parent.children.map((c) => (c === el ? replacement : c));
    return SKIP;
  });

  selectEndnoteAreas(tree).forEach((area) => removeElement(tree, area));
};

/**
 * Process Markdown AST.
 */
export const mdast = [endnotes, { inlineNotes: true }];

/**
 * Process footnote-related Hypertext AST.
 * When endnotesAsFootnotes is enabled, converts endnotes to inline GCPM footnotes.
 * Otherwise, resolves HTML diffs between `remark-footnotes` and Pandoc footnotes.
 */
export const hast =
  (options: FootnoteOptions = {}) =>
  (tree: HastRoot) => {
    if (options.endnotesAsFootnotes) {
      convertEndnotesToFootnotes(tree, options);
    } else {
      transformEndnoteCalls(tree);
      transformEndnoteAreas(tree);
    }
  };
